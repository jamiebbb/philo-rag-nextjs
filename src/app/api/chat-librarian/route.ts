import { NextRequest, NextResponse } from 'next/server'
import { createServerSupabaseClient } from '@/lib/supabase'
import { generateChatCompletion, generateEmbedding } from '@/lib/openai'

interface LibrarianResponse {
  response: string
  sources: any[]
  recommendations: any[]
  readingLists?: any[]
  missingMaterials?: any[]
  libraryStats?: any
  searchStrategy: string
}

// Comprehensive librarian retrieval that combines multiple approaches
async function librarianRetrieve(query: string, supabase: any): Promise<LibrarianResponse> {
  console.log('ðŸ“š Librarian retrieval for:', query)
  
  // Analyze query intent for librarian services
  const queryIntent = await analyzeLibrarianIntent(query)
  console.log('ðŸŽ¯ Librarian intent:', queryIntent)
  
  let sources: any[] = []
  let recommendations: any[] = []
  let missingMaterials: any[] = []
  let searchStrategy = 'hybrid_librarian'
  
  // Get available documents for context
  const catalogResults = await getLibraryCatalog(supabase, queryIntent)
  
  // Retrieve relevant documents if knowledge query
  if (queryIntent.needsRetrieval) {
    const queryEmbedding = await generateEmbedding(query)
    
    const { data: vectorDocs, error: vectorError } = await supabase.rpc('match_documents_enhanced', {
      query_embedding: queryEmbedding,
      match_threshold: 0.1,
      match_count: 8
    })
    
    if (!vectorError && vectorDocs) {
      sources = vectorDocs.map((doc: any) => ({
        title: doc.title || 'Unknown Document',
        author: doc.author || 'Unknown Author',
        doc_type: doc.doc_type || 'Book',
        genre: doc.genre,
        topic: doc.topic,
        difficulty: doc.difficulty,
        content: doc.content?.substring(0, 400) || '',
        relevance_score: doc.similarity,
        total_chunks: doc.total_chunks || 1
      }))
    }
  }
  
  // Generate recommendations based on query and available materials
  if (queryIntent.needsRecommendations) {
    recommendations = await generateRecommendations(query, catalogResults, queryIntent)
  }
  
  // Identify missing materials if requested
  if (queryIntent.needsGapAnalysis) {
    missingMaterials = await identifyMissingMaterials(query, catalogResults)
  }
  
  return {
    response: '', // Will be generated by AI
    sources,
    recommendations,
    missingMaterials,
    libraryStats: catalogResults.stats,
    searchStrategy
  }
}

// Analyze what type of librarian service is needed
async function analyzeLibrarianIntent(query: string) {
  const queryLower = query.toLowerCase()
  
  return {
    needsRetrieval: /\b(tell me about|explain|what is|based on|according to)\b/i.test(query),
    needsRecommendations: /\b(recommend|suggest|reading list|books? about|materials? on)\b/i.test(query),
    needsGapAnalysis: /\b(missing|don't have|need to add|acquire|purchase)\b/i.test(query),
    isCatalogBrowse: /\b(show|list|catalog|inventory|browse|what do you have)\b/i.test(query),
    isGuidance: /\b(how to|guide|help me|where to start)\b/i.test(query),
    topic: extractMainTopic(query),
    difficulty: extractDifficulty(query),
    queryType: determineQueryType(query)
  }
}

function extractMainTopic(query: string): string {
  // Extract key topics from query for better recommendations
  const topics = ['philosophy', 'business', 'psychology', 'economics', 'management', 
                 'leadership', 'strategy', 'finance', 'marketing', 'innovation']
  
  for (const topic of topics) {
    if (query.toLowerCase().includes(topic)) {
      return topic
    }
  }
  return 'general'
}

function extractDifficulty(query: string): string {
  if (/\b(beginner|introduction|intro|basic|simple)\b/i.test(query)) return 'Beginner'
  if (/\b(advanced|expert|complex|deep)\b/i.test(query)) return 'Advanced'
  if (/\b(intermediate|moderate)\b/i.test(query)) return 'Intermediate'
  return 'any'
}

function determineQueryType(query: string): string {
  if (/\b(recommend|suggest)\b/i.test(query)) return 'recommendation'
  if (/\b(catalog|list|browse|show)\b/i.test(query)) return 'catalog'
  if (/\b(tell me|explain|what is)\b/i.test(query)) return 'knowledge'
  if (/\b(guide|help|how to)\b/i.test(query)) return 'guidance'
  return 'general'
}

// Get comprehensive library catalog with stats
async function getLibraryCatalog(supabase: any, intent: any) {
  const { data: allDocs, error } = await supabase
    .from('documents_enhanced')
    .select('title, author, doc_type, genre, topic, difficulty, tags, summary')
    .order('title')
  
  if (error) {
    console.error('Error fetching catalog:', error)
    return { books: [], stats: {} }
  }
  
  // Deduplicate into unique books
  const booksMap = new Map()
  
  allDocs?.forEach((doc: any) => {
    const title = doc.title?.trim()
    const author = doc.author?.trim() || 'Unknown Author'
    
    if (!title) return
    
    const bookKey = `${title.toLowerCase()}-${author.toLowerCase()}`
    if (!booksMap.has(bookKey)) {
      booksMap.set(bookKey, {
        title,
        author,
        doc_type: doc.doc_type || 'Book',
        genre: doc.genre,
        topic: doc.topic,
        difficulty: doc.difficulty,
        tags: doc.tags,
        summary: doc.summary
      })
    }
  })
  
  const books = Array.from(booksMap.values())
  
  // Generate library statistics
  const stats: any = {
    total_books: books.length,
    by_genre: {},
    by_topic: {},
    by_difficulty: {},
    by_type: {}
  }
  
  books.forEach((book: any) => {
    // Count by genre
    const genre = book.genre || 'Uncategorized'
    stats.by_genre[genre] = (stats.by_genre[genre] || 0) + 1
    
    // Count by topic
    const topic = book.topic || 'General'
    stats.by_topic[topic] = (stats.by_topic[topic] || 0) + 1
    
    // Count by difficulty
    const difficulty = book.difficulty || 'Unknown'
    stats.by_difficulty[difficulty] = (stats.by_difficulty[difficulty] || 0) + 1
    
    // Count by type
    const type = book.doc_type || 'Unknown'
    stats.by_type[type] = (stats.by_type[type] || 0) + 1
  })
  
  return { books, stats }
}

// Generate intelligent recommendations
async function generateRecommendations(query: string, catalogData: any, intent: any) {
  const { books } = catalogData
  
  // Filter books based on intent
  let candidates = books
  
  if (intent.topic !== 'general') {
    candidates = books.filter((book: any) => 
      book.topic?.toLowerCase().includes(intent.topic) ||
      book.genre?.toLowerCase().includes(intent.topic) ||
      book.tags?.toLowerCase().includes(intent.topic)
    )
  }
  
  if (intent.difficulty !== 'any') {
    candidates = candidates.filter((book: any) => 
      book.difficulty === intent.difficulty
    )
  }
  
  // Sort by relevance and return top recommendations
  return candidates
    .slice(0, 5)
    .map(book => ({
      ...book,
      recommendation_reason: generateRecommendationReason(book, intent),
      recommendation_type: 'library_collection'
    }))
}

function generateRecommendationReason(book: any, intent: any): string {
  const reasons = []
  
  if (book.topic && intent.topic !== 'general') {
    reasons.push(`relevant to ${intent.topic}`)
  }
  
  if (book.difficulty) {
    reasons.push(`${book.difficulty.toLowerCase()} level`)
  }
  
  if (book.genre) {
    reasons.push(`${book.genre.toLowerCase()} genre`)
  }
  
  return reasons.length > 0 ? `Recommended because it's ${reasons.join(' and ')}` : 'Matches your query'
}

// Identify materials missing from collection
async function identifyMissingMaterials(query: string, catalogData: any) {
  // This would typically integrate with external APIs or knowledge bases
  // For now, return common missing materials based on query analysis
  
  const { books } = catalogData
  const queryLower = query.toLowerCase()
  
  // Example gap analysis for business topics
  if (queryLower.includes('business') || queryLower.includes('management')) {
    const businessBooks = books.filter(book => 
      book.topic?.toLowerCase().includes('business') ||
      book.genre?.toLowerCase().includes('business')
    )
    
    // Common business classics that might be missing
    const essentialBusinessBooks = [
      { title: 'Good to Great', author: 'Jim Collins', reason: 'Essential management text' },
      { title: 'The Lean Startup', author: 'Eric Ries', reason: 'Modern entrepreneurship guide' },
      { title: 'Thinking, Fast and Slow', author: 'Daniel Kahneman', reason: 'Decision-making foundation' }
    ]
    
    return essentialBusinessBooks
      .filter(essential => 
        !businessBooks.some(book => 
          book.title.toLowerCase().includes(essential.title.toLowerCase())
        )
      )
      .map(book => ({
        ...book,
        suggestion_type: 'missing_essential',
        acquisition_priority: 'high'
      }))
  }
  
  return []
}

export async function POST(request: NextRequest) {
  try {
    const { message, chatId, chatHistory = [] } = await request.json()

    if (!message) {
      return NextResponse.json({ error: 'Message is required' }, { status: 400 })
    }

    console.log('ðŸ“š Librarian Chat API called with message:', message)

    const supabase = createServerSupabaseClient()

    // Perform librarian-specific retrieval and analysis
    const librarianResult = await librarianRetrieve(message, supabase)

    // Build conversation context
    let conversationContext = ''
    if (chatHistory.length > 0) {
      const recentHistory = chatHistory.slice(-4)
      conversationContext = '\n\nCONVERSATION CONTEXT:\n'
      recentHistory.forEach((msg: any) => {
        const role = msg.role === 'user' ? 'User' : 'Librarian'
        const content = msg.content.length > 150 ? msg.content.substring(0, 150) + '...' : msg.content
        conversationContext += `${role}: ${content}\n`
      })
    }

    // Enhanced librarian system prompt
    const systemPrompt = `You are PHILO, the expert librarian for an advanced Reading Room specializing in business, philosophy, and professional development. You have access to a curated knowledge collection and can provide comprehensive library services.

LIBRARY STATISTICS:
${JSON.stringify(librarianResult.libraryStats, null, 2)}

YOUR CAPABILITIES:
1. Answer questions using knowledge from your collection (${librarianResult.sources.length} relevant sources found)
2. Recommend reading materials from your ${librarianResult.libraryStats?.total_books || 0} book collection
3. Identify gaps in the collection and suggest acquisitions
4. Provide reading guidance and learning pathways
5. Supplement with general knowledge when needed

CURRENT RETRIEVAL RESULTS:
${librarianResult.sources.length > 0 ? 
  librarianResult.sources.map((source, i) => 
    `Source ${i+1}: "${source.title}" by ${source.author} (${source.doc_type})
    Content: ${source.content}`
  ).join('\n\n') : 'No specific documents retrieved for this query.'}

RECOMMENDATIONS AVAILABLE:
${librarianResult.recommendations.length > 0 ?
  librarianResult.recommendations.map((rec, i) =>
    `${i+1}. "${rec.title}" by ${rec.author} - ${rec.recommendation_reason}`
  ).join('\n') : 'No specific recommendations generated.'}

MISSING MATERIALS IDENTIFIED:
${librarianResult.missingMaterials?.length > 0 ?
  librarianResult.missingMaterials.map((missing, i) =>
    `${i+1}. "${missing.title}" by ${missing.author} - ${missing.reason}`
  ).join('\n') : 'No gaps identified for this query.'}

RESPONSE GUIDELINES:
1. Act as a knowledgeable, helpful librarian who knows the collection intimately
2. Answer questions using retrieved sources when available
3. Proactively suggest related materials from the collection
4. Identify learning pathways and reading sequences
5. Mention when materials aren't in the collection and suggest alternatives
6. Use your general knowledge to supplement the collection when appropriate
7. Always cite specific sources when making factual claims
8. Offer to help with research strategies and finding additional resources

PERSONALITY: Professional yet approachable, scholarly but not intimidating, genuinely helpful and curious about the user's learning journey.

${conversationContext}

User Question: ${message}`

    const response = await generateChatCompletion([
      { role: 'system', content: systemPrompt },
      { role: 'user', content: message }
    ])

    return NextResponse.json({
      response,
      sources: librarianResult.sources,
      recommendations: librarianResult.recommendations,
      missingMaterials: librarianResult.missingMaterials,
      libraryStats: librarianResult.libraryStats,
      searchStrategy: librarianResult.searchStrategy,
      conversationContextUsed: chatHistory.length > 0,
      method: 'librarian_comprehensive'
    })

  } catch (error) {
    console.error('Error in librarian chat API:', error)
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    )
  }
}